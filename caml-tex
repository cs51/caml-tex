#!/usr/bin/perl

# SMS 151022: Added better method for finding the end of the startup
# material and the start of the actual evaluations.
#
# Remaining issues: May not properly deal (things get out of sync)
# with cases that don't yield output, e.g.,
#
#    # let () = () ;;
#
# Doesn't handle trailing comments properly (sync problems again), e.g., 
#
#    # 2 + 3 ;; (* comment *)
#
# though it works fine with, e.g.,
#
#    # 2 + 3 (* comment *) ;;

$linelen = 72;
$output = "";
$cut_at_blanks = 0;

$| = 1;    # force flushing

# read options
while ($#ARGV >= 0) {
  $_ = $ARGV[0];
  print $_
  last unless (/^-/);
  $linelen = $ARGV[1], shift, shift, next    if (/^-n$/);
  $output  = $ARGV[1], shift, shift, next    if (/^-o$/);
  $cut_at_blanks = 1, shift, next            if (/^-w$/);
  printf STDERR ("Unknown option '%s', ignored\n", $_);
  shift;
}

# First pass: extract the Caml phrases to evaluate

open(ML, "> input.ml") || die("Cannot create input.ml : $!");

# SMS: Insert a startup message to track end of banner and startup
# material
$startupinput = "\"01234\" ^ \"56789\" ;;\n";
$startupoutput = "0123456789";
print ML $startupinput; 

foreach $infile (@ARGV) {
  open(IN, $infile) || die("Cannot open $infile : $!");
  while(<IN>) {
    if (m/^\\begin{caml_(example|example\*|eval)}\s*$/) {
      while(<IN>) {
        last if m/^\\end{caml_(example|example\*|eval)}\s*$/;
        print ML $_;
      }
    }
  }
  close(IN);
}

close(ML);

# Feed the phrases to a Caml toplevel

open(TOPLEVEL, "ocaml 2>&1 < input.ml |") ||
       die("Cannot start ocaml : $!");

# SMS: Skip until the startup message has been found, thereby skipping
# over the banner and other starting material.
while (<TOPLEVEL> !~ /$startupoutput/) {next;}

$lastread = <TOPLEVEL>;
$lastread =~ s/^#\s*//;

# Second pass: shuffle the TeX source and the output of the toplevel

# Open the output file
if ($output) {
  if ($output eq "-") {
    open(OUT, ">&STDOUT");
  } else {
    open(OUT, ">$output") || die("Cannot create $output: $!");
  }
}

foreach $infile (@ARGV) {
  open(IN, $infile) || die("Cannot open $infile: $!");
  if (! $output) {
    $outfile = $infile;
    $outfile =~ s/\.tex$//;
    open(OUT, "> $outfile.ml.tex") || die("Cannot create $outfile.ml.tex: $!");
  }
  while(<IN>) {
    if (m/^\\begin{caml_example(\*?)}\s*$/) {
      $omit_answer = $1;     # true if caml_example*, false if caml_example
      print OUT "\\begin\{caml\}\n";
      $severalphrases = 0;
      while(<IN>) {
        last if m/\\end{caml_example\*?}\s*$/;
        print OUT "\\;" if ($severalphrases);
        while(1) {
	  # SMS: Here and below, I had to update the replacements of
	  # braces and backslashes, because the sequential method
	  # originally used fails badly. Instead, I replace them with
	  # intermediate values and then replace the intermediate
	  # values, the net effect being parallel replacement.
	  #
	  # s/\{/\\\{/g; s/\}/\\\}/g;
	  # s/\\/\\camlbslash\{\}/g;
	  s/\{/<<<openbrace>>>/g;
	  s/\}/<<<closebrace>>>/g;
	  s/\\/<<<backslash>>>/g;
	  s/<<<openbrace>>>/\\\{/g;
	  s/<<<closebrace>>>/\\\}/g;
	  s/<<<backslash>>>/\\camlbslash\{\}/g;
          s/\n//g;
          print OUT "\\?\{", $_, "\}\n";
          last if m/;;\s*$/;
          $_ = <IN>;
        }
        while($lastread) {
          last if $lastread =~ s/^#\s*//;
          print $lastread unless ($output eq "-");
          if (! $omit_answer) {
            while (length($lastread) > $linelen) {
              if ($cut_at_blanks) {
                $cutpos = rindex($lastread, ' ', $linelen);
                if ($cutpos == -1) { $cutpos = $linelen; } else { $cutpos++; }
              } else {
                $cutpos = $linelen;
              }
              $line = substr($lastread, 0, $cutpos);
              #$line =~ s/\{/\\\{/g;
              #$line =~ s/\}/\\\}/g;
              #$line =~ s/\\/\\camlbslash\{\}/g;
	      $line =~ s/\{/<<<openbrace>>>/g;
	      $line =~ s/\}/<<<closebrace>>>/g;
	      $line =~ s/\\/<<<backslash>>>/g;
	      $line =~ s/<<<openbrace>>>/\\\{/g;
	      $line =~ s/<<<closebrace>>>/\\\}/g;
	      $line =~ s/<<<backslash>>>/\\camlbslash\{\}/g;

              print OUT "\\:\{", $line, "\}\n";
              $lastread = substr($lastread, $cutpos,
                                 length($lastread) - $cutpos);
            }
            #$lastread =~ s/\{/\\\{/g;
            #$lastread =~ s/\}/\\\}/g;
            #$lastread =~ s/\\/\\camlbslash\{\}/g;
	    $lastread =~ s/\{/<<<openbrace>>>/g;
	    $lastread =~ s/\}/<<<closebrace>>>/g;
	    $lastread =~ s/\\/<<<backslash>>>/g;
	    $lastread =~ s/<<<openbrace>>>/\\\{/g;
	    $lastread =~ s/<<<closebrace>>>/\\\}/g;
	    $lastread =~ s/<<<backslash>>>/\\camlbslash\{\}/g;
            $lastread =~ s/\n//g;
            print OUT "\\:\{", $lastread, "\}\n";
          }
          $lastread = <TOPLEVEL>;
        }
        $severalphrases = 1;
      }
      print OUT "\\end\{caml\}\n";
    }
    elsif (m/^\\begin{caml_eval}\s*$/) {
      while(<IN>) {
        last if m/^\\end{caml_eval}\s*$/;
        if (m/;;\s*$/) {
          while($lastread) {
            last if $lastread =~ s/^#//;
            print $lastread;
            $lastread = <TOPLEVEL>;
          }
        }
      }
    }
    else {
      print OUT $_;
    }
  }
  close(IN);
}

close(TOPLEVEL);
#unlink("input.ml");
